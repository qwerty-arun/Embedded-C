# Embedded C

## Bitwise Operations
- Set or Clear a Specific Bit in a Register
- Bit Toggle
- Check if K-th Bit is Set
- Set the Bit in an 8-bit Register
- Clear the Bit in an 8-bit Register
- Toggle the Bit in an 8-bit Register
- Is the Bit Set
- Set Specific Bits in a 32-bit Register
- Keep Only the Highest Set Bit
- Bit Operations using Macros
- Decode Status Register into Human-Readable Flags
- Bit Spreading Interleave Bits with Zeros
- Macro-Based Register Config Helper

## Bit Field Operations
- Extract the Nibble form an 8-bit Register
- Set Multiple Bits in 8-bit Register
- Extract a Bit Field from a 32-bit Register
- Clear Specific Bits in a 32-bit Register
- Replace Bit Field in a 32-bit Register
- Extract Even Bits Only from 32-bit Register
- Set Baud Rate Field in Control Register
- Data Transmission
- Pack Multiple Fields into a 16-bit Control Register
- Extract and Modify Field in a 32-bit Register
- Extract Bit Field from 16-bit Register

## Bitwise Rotation and Counting
- Count Set Bits in an integer
- Rotate Left in an 8-bit Register
- Rotate Right in a 32-bit Register
- Detect Circular Pattern Match
- Count Set Bits in an 8-bit Register
- Check if a Number is a Power of Two
- Bit Reversal in an 8-bit Value
- Compress Interleaved Bits Reverse Bit Spreading

## Array Manipulation
- Checksum Validation
- Reverse an Array in-place
- Left Rotate Array by K Positions
- Find Duplicate in Range 0 and n-1
- Sliding Window Sum
- Serialized Data Buffer

## Pointer
- Pointer-Swap Value
- Print Sum of Even Numbers
- Reverse an Array Using Only Pointers
- Find Maximum Element Using Pointer Walk
- Calculate Array Sum Using Only Pointers
- Double Pointer
- Swap Two Pointers Using Double Pointers
- Add Two Integers Using Void Pointers
- Function Pointer Dispatch Table
- State Machine Using Function Pointers
- Simulate memcpy function Using Pointer Walk
- Scan Memory for Three Consecutive Increasing Values
- Detect Alternating Pattern
- Event-Based Triggers Using Function Pointer Array
- void pointer and Casting

## Unions
- Control Register Using Nested Bitfields
- Union Extract Bytes from a 32-bit Value
- Modify Bytes in a 32-bit Value Using Union
- Packet Layout Using Union with Struct
- Decode ADC Result Using Union Bitfields
- Transmit Float as Byte Stream Using Union

## Structures
- Pointer to Struct with Bitfields
- Construct UART Data Frame with Parity Bit
- Validate Configuration Register Layout
- Struct Padding
- Extract Packet Fields from Byte Stream
- Register Bitfields Using Struct Overlay
- Filter Structs by Field Value for example Sensor Threshold

## Circular Buffers and Stack
- Circular Buffer Insert
- Circular Buffer Read
- Peek N Bytes from Circular Buffer
- Implement Stack Using Array with Push and Pop Operations

## Strings and Character Handling
- Implement Custom strlen Function
- Implement Custom strcpy Function
- Implement Custom strcmp Function
- Reverse a String In-Place
- Remove Duplicate Characters from a String
- Count Alphabets Digits and Symbols in a String
- Convert Uppercase Letters to Lowercase
- Parse Comma-Separated Integers into an Array
- Convert String to Integer
- Check if the String Numeric or Alphabetic
- Convert a String to Float
- Split a String Using Delimiter
- Split a GPS String for Time and Coordinates
- Implement a Simple Shell Command Parser

## Searching and Sorting
- Linear Search in Array
- Binary Search in Sorted Array
- Find Minimum and Maximum in an Array
- Sort an Array in Ascending Order
- Sort an Array in Descending Order
- Find Kth Smallest and Kth Largest Element
- Find Top 3 Largest Values in an Array

## Data Conversion and Encoding
- Little Endian to Big Endian
- Print Binary Representation of an 8-bit or 16-bit Value
- Convert Decimal Number to Binary or Hex Without itoa function
- Convert Integer to String
- Convert Binary String to Integer without strtoI function or Library
- Convert Hexadecimal String to Integer Without strtol or sscanf function
- Convert Integer to Hex Strings without sprintf or itoa functions 

## Arithmetic Edge Cases
- Carry Flag in 8-bit Addition
- Detect Underflow in Unsigned Subtraction
- Identify Trap in Signed vs Unsigned Comparision
- Add Signed and Unsigned Integers Safely